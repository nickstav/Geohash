{"version":3,"sources":["Components/Splash.js","Components/TopBar.js","Algorithms/map.js","Components/Map.js","Algorithms/stringAlgorithm.js","Components/StringInput.js","Algorithms/userLocation.js","Algorithms/locationAlgorithm.js","Components/UserLocation.js","Algorithms/urlQuery.js","Components/App.js","index.js"],"names":["Splash","id","href","target","TopBar","toggleMenu","className","onClick","L","window","Map","props","state","map","marker","label","polygon","initialZoomLevel","this","latitude","longitude","maxLatitude","maxLongitude","minLatitude","minLongitude","showResults","lat","long","newMap","setView","tileLayer","attribution","addTo","loadMap","newMarker","createMarker","writeLabel","fitBounds","getBounds","bindPopup","openPopup","setZoom","setLatLng","setLatLngs","toFixed","React","Component","getLocation","string","binaryCoords","binaryString","character","binaryValue","getBinaryRepresentation","console","error","i","length","splitBinaryIntoLatLong","getLatLongAsBinary","getGeoCoords","min","max","averageLatitude","average","averageLongitude","decimalValue","indexOf","decimal","binaryNumber","toString","convertToBinary","range","pop","shift","newMidPoint","splice","StringInput","updateString","event","setState","value","getGeohash","alert","geohash","showMap","coords","Fragment","type","size","onChange","fontSize","renderMap","getUserLocation","a","navigator","geolocation","log","getCoords","position","Promise","res","rej","getCurrentPosition","getLocationAccuracy","stringLength","coord","totalBits","latitudeAccuracy","Math","pow","floor","longitudeAccuracy","round","getStringForGivenLatLong","accuracy","latitudeBinary","binaryArray","bits","decimals","join","bit","substring","push","j","parseInt","decimalArray","charAt","convertDecimalToString","getGeohashString","array1","array2","result","mergeArrays","coordBitLength","totalLength","getBitLengthForLatOrLong","UserLocation","setCharacterLength","getString","userLocation","latAccuracy","longAccuracy","requestSubmitted","step","defaultValue","onInput","getURLQueryGeohash","params","urlQuery","URLSearchParams","location","search","has","get","replace","App","changeFunction","function","menuOpen","appStarted","checkForURLQuery","name","renderMenu","renderSplash","switchAppFunction","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.99e8ecab.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nfunction Splash() {\r\n    return (\r\n        <div id=\"intro\">\r\n            <h2>Welcome to the world of Geohashing!</h2>\r\n            <p>Please select an option from the menu above</p>\r\n            <a href=\"https://en.wikipedia.org/wiki/Geohash\" target=\"_blank\">(what is Geohashing?)</a>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport { Splash }","import React from 'react';\r\n\r\nfunction TopBar({toggleMenu}) {\r\n        return (\r\n            <div id=\"topBar\">\r\n                <h1>GEOHASH</h1>\r\n                <button className=\"menu\" onClick={toggleMenu}></button>\r\n            </div>\r\n        )\r\n}\r\n\r\nexport { TopBar }","const L = window.L;\r\n\r\nfunction loadMap(lat, long) {\r\n    let newMap = L.map('mapDiv').setView([lat,long], 1);\r\n    const attribution = '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors';\r\n    const tileUrl = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';\r\n    const tiles = L.tileLayer(tileUrl, { attribution });\r\n    tiles.addTo(newMap);\r\n  \r\n    return newMap;\r\n}\r\n  \r\nfunction createMarker(map, lat, long) {\r\n    let newMarker = L.marker([lat, long]);\r\n    newMarker.addTo(map);\r\n  \r\n    return newMarker;\r\n}\r\n\r\nexport { loadMap, createMarker };","import React from 'react';\r\nimport { loadMap, createMarker } from '../Algorithms/map.js';\r\nlet L = window.L;\r\n\r\nclass Map extends React.Component {\r\n    //need to define the map after the component has mounted the <div> in which it belongs\r\n    constructor(props, state) {\r\n      super(props);\r\n      this.map = null;\r\n      this.marker = null;\r\n      this.label = null;\r\n      this.polygon = null;\r\n      this.initialZoomLevel = 8;\r\n    }\r\n  \r\n    componentDidMount() {\r\n      const { latitude, longitude, maxLatitude, maxLongitude, minLatitude, minLongitude, showResults } = this.props;\r\n  \r\n      this.map = loadMap(latitude, longitude);\r\n      this.marker = createMarker(this.map, latitude, longitude);\r\n      this.label = this.writeLabel();\r\n      this.polygon = L.polygon([\r\n        [maxLatitude, minLongitude],\r\n        [maxLatitude, maxLongitude],\r\n        [minLatitude, maxLongitude],\r\n        [minLatitude, minLongitude]\r\n      ]);\r\n  \r\n      if (showResults) {\r\n        this.polygon.addTo(this.map);\r\n        this.map.fitBounds(this.polygon.getBounds());\r\n        this.marker.bindPopup(this.label).openPopup();\r\n      } else {\r\n        //set an arbitrary zoom level centred on user's location\r\n        this.map.setZoom(this.initialZoomLevel);\r\n      }\r\n    }\r\n    //above function only called once, so ensure map properties are updated along with new props values\r\n    componentDidUpdate() { \r\n      const { latitude, longitude, maxLatitude, maxLongitude, minLatitude, minLongitude, showResults } = this.props;\r\n  \r\n      this.marker.setLatLng([latitude, longitude]);\r\n      this.polygon.setLatLngs([\r\n        [maxLatitude, minLongitude],\r\n        [maxLatitude, maxLongitude],\r\n        [minLatitude, maxLongitude],\r\n        [minLatitude, minLongitude]\r\n      ]);\r\n      this.label = this.writeLabel();\r\n  \r\n      if (showResults) {\r\n        this.polygon.addTo(this.map);\r\n        this.map.fitBounds(this.polygon.getBounds());\r\n        this.marker.bindPopup(this.label).openPopup();\r\n      }\r\n    }\r\n    writeLabel() {\r\n  \r\n      const { label, latitude, longitude } = this.props;\r\n  \r\n      if (label === 'userString') {\r\n        return `estimated location: ${latitude.toFixed(2)}°, \r\n                ${longitude.toFixed(2)}°`;\r\n      } else if (label !== null) {\r\n        return `Geohash string for current location: <b>${label}</b>`;\r\n      } else if (label === null) {\r\n        return 'Getting string...';\r\n      } else {\r\n        return 'Error getting label';\r\n      }\r\n    }\r\n    render() {\r\n      return (\r\n        <div id=\"mapHolder\">\r\n          <div id=\"mapFrame\">\r\n            <div id='mapDiv'></div>\r\n          </div>\r\n        </div>\r\n      )\r\n    }\r\n  }\r\n\r\n  export { Map }","function getLocation(string) {\r\n    let binaryCoords = getLatLongAsBinary(string)\r\n\r\n    if (binaryCoords === null) {\r\n        return null;\r\n    }\r\n\r\n    let latitudeRange = [-90, 0, 90];\r\n    let longitudeRange = [-180, 0, 180];\r\n\r\n    let latitude = getGeoCoords(binaryCoords.latitude, latitudeRange);\r\n    let longitude = getGeoCoords(binaryCoords.longitude, longitudeRange);\r\n\r\n    return {\r\n            minLatitude: latitude.min,\r\n            maxLatitude: latitude.max,\r\n            averageLatitude: latitude.average,\r\n            minLongitude: longitude.min,\r\n            maxLongitude: longitude.max,\r\n            averageLongitude: longitude.average\r\n            };\r\n}\r\n\r\n// function to turn string of chracters into their binary representations and join them together\r\nfunction getLatLongAsBinary(string) {\r\n    let binaryString = '';\r\n    for (const character of string) {\r\n        let binaryValue = getBinaryRepresentation(character);\r\n        if (binaryValue === null) {\r\n            console.error(`Invalid character: ${character}`);\r\n            return null;\r\n        } else {\r\n            binaryString = binaryString + binaryValue;\r\n        }\r\n    }\r\n    \r\n    return splitBinaryIntoLatLong(binaryString)\r\n}\r\n\r\n\r\nfunction getBinaryRepresentation(character) {\r\n    // define geohash alphabet as a string where the index represents the decimal value\r\n    const base32 = '0123456789bcdefghjkmnpqrstuvwxyz';\r\n    let decimalValue = base32.indexOf(character);\r\n\r\n    //if the character is not in the string, indexOf() returns -1\r\n    if (decimalValue === -1) {\r\n        return null;\r\n    } else {\r\n        return convertToBinary(decimalValue);\r\n    }\r\n}\r\n\r\n\r\n// function to split a binary string into its even characters (longitude) & odd characters (latitude)\r\nfunction splitBinaryIntoLatLong(string) {\r\n    let latitude = '';\r\n    let longitude = '';\r\n\r\n    for (let i = 0; i < string.length; i++) {\r\n        if (i === 0 || i%2 === 0) {\r\n            longitude = longitude + string[i]; \r\n        } else {\r\n            latitude = latitude + string[i];\r\n        };\r\n    }\r\n\r\n    return {latitude, longitude};\r\n}\r\n\r\n\r\nfunction convertToBinary(decimal) {\r\n    let binaryNumber = decimal.toString(2);\r\n\r\n    //we want a binary representation of 5 bits, so add relevant no. 0s to start of smaller values\r\n    while (binaryNumber.length < 5) {\r\n        binaryNumber = '0' + binaryNumber;\r\n    }\r\n\r\n    return binaryNumber;\r\n}\r\n\r\n\r\nfunction getGeoCoords(binaryCoords, range) {\r\n    // take the first or second half of the array range depending on whether the bit is 0 or 1\r\n    for (let i = 0; i < binaryCoords.length; i++) {\r\n        if (binaryCoords[i] === '0') {\r\n            // if 0 remove last element of array\r\n            range.pop();\r\n        } else {\r\n            // if 1 remove first entry of array\r\n            range.shift();\r\n        }\r\n        // define the new average value and add to the middle of the range array\r\n        let newMidPoint = (range[0] + range[1]) / 2;\r\n        range.splice(1, 0, newMidPoint);\r\n    }\r\n    // return the final average value\r\n    return {\r\n            min: range[0], \r\n            max: range[2], \r\n            average: range[1]\r\n            };\r\n}\r\n\r\n\r\nexport { getLocation }","import React from 'react';\r\nimport { Map } from './Map.js';\r\nimport { getLocation } from '../Algorithms/stringAlgorithm.js';\r\n\r\nclass StringInput extends React.Component {\r\n    constructor(props) {\r\n      super(props);\r\n      this.state = {\r\n        string: this.props.string,\r\n        coords: null,\r\n        showMap: false\r\n      };\r\n    }\r\n    componentDidMount() {\r\n      //show result of any URL Query that has been detected\r\n      if (this.state.string.length > 1) {\r\n        this.getGeohash();\r\n      }\r\n    }\r\n\r\n    updateString = (event) => {\r\n      this.setState({string: event.target.value});\r\n    }\r\n    getGeohash = () => {\r\n      if (this.state.string.length < 2 || this.state.string.length > 12) {\r\n        alert('Error: Please enter a string of length 2-12 characters');\r\n        return;\r\n      }\r\n      let geohash = getLocation(this.state.string);\r\n      if (geohash === null) {\r\n        alert('Error: One or more characters are not valid for Geohashing')\r\n      } else {\r\n        this.setState({\r\n          showMap: true,\r\n          coords: geohash\r\n        });\r\n      } \r\n    }\r\n    renderMap() {\r\n      if (this.state.showMap) {\r\n        return (\r\n          <Map \r\n            latitude={this.state.coords.averageLatitude}\r\n            longitude={this.state.coords.averageLongitude}\r\n            minLatitude={this.state.coords.minLatitude}\r\n            maxLatitude={this.state.coords.maxLatitude}\r\n            minLongitude={this.state.coords.minLongitude}\r\n            maxLongitude={this.state.coords.maxLongitude}\r\n            label={'userString'}\r\n            showResults={true}\r\n          />\r\n        )\r\n      }\r\n    }\r\n    render() {\r\n      return (\r\n        <React.Fragment>\r\n          <h2>Find a location</h2>\r\n          <p>Enter a 2-12 character string using the Geohash alphabet:</p>\r\n          <p className=\"instructions\">\r\n            The Geohash alphabet [32ghs] uses all\r\n            digits 0-9 and almost all <b>lower case</b> letters except a, i, l and o.\r\n          </p>\r\n          <div id=\"textInputWrapper\">\r\n            <input\r\n            value={this.state.string}\r\n              type=\"text\"\r\n              size=\"12\"\r\n              onChange={this.updateString}\r\n              fontSize=\"50\"\r\n            />\r\n          </div>\r\n          <div id=\"buttonWrapper\">\r\n            <input\r\n              type=\"button\"\r\n              value=\"Submit\"\r\n              onClick={this.getGeohash}\r\n            />\r\n          </div>\r\n          {this.renderMap()}\r\n          </React.Fragment>\r\n      );\r\n    }\r\n  }\r\n\r\n  export { StringInput };","async function getUserLocation() {\r\n    if (navigator.geolocation) {\r\n        console.log(\"geolocation available\");\r\n        let position = await getCoords();\r\n        return {\r\n            latitude: position.coords.latitude,\r\n            longitude: position.coords.longitude\r\n        };\r\n    } else {\r\n        console.log('geolocation not available');\r\n        return null;\r\n    };\r\n;}\r\n\r\nfunction getCoords() {\r\n    try {\r\n        return new Promise((res, rej) => {\r\n            navigator.geolocation.getCurrentPosition(res, rej);\r\n        });\r\n    } catch (error) {\r\n        console.error(error);\r\n    }\r\n}\r\n\r\nfunction getLocationAccuracy(stringLength, coord) {\r\n//the nth bit gives an max error of (initial max error) / 2^n\r\n//(eg error for latitude reduces from 45 to 22.5, 11.25, 5.625, etc)\r\n  let totalBits = 5 * stringLength;\r\n  let latitudeAccuracy = 45 / Math.pow(2, Math.floor(totalBits/2));\r\n  let longitudeAccuracy = 90 / Math.pow(2, Math.round(totalBits/2));\r\n\r\n  if (coord === \"lat\") {\r\n      return latitudeAccuracy;\r\n  } else if (coord === \"long\") {\r\n      return longitudeAccuracy;\r\n  }\r\n}\r\n\r\n\r\nexport { getUserLocation, getLocationAccuracy }","function getStringForGivenLatLong(coords, stringLength) {\r\n    if (coords === null) {\r\n        return null;\r\n    }\r\n    let latitudeRange = [-90, 0, 90];\r\n    let longitudeRange = [-180, 0, 180];\r\n    let accuracy = stringLength;\r\n\r\n    let latitudeBinary = convertToBinary(coords.latitude, latitudeRange, accuracy);\r\n    let longitudeBinary = convertToBinary(coords.longitude, longitudeRange, accuracy);\r\n\r\n    let binaryRepresentation = mergeArrays(longitudeBinary, latitudeBinary);\r\n\r\n    return getGeohashString(binaryRepresentation);\r\n}\r\n\r\nfunction convertToBinary(coords, range, accuracy) {\r\n    let bits = [];\r\n    //5 bits for each character of the string\r\n    let totalBitLength = 5 * accuracy;\r\n    let coordBitLength = getBitLengthForLatOrLong(totalBitLength, range);\r\n    for (let i = 0; i < coordBitLength; i++) {\r\n            if (coords < range[1]) {\r\n                bits.push('0');\r\n                // if 0 remove last element of array\r\n                range.pop();\r\n            } else if (coords > range[1]) {\r\n                bits.push('1');\r\n                // if 1 remove first entry of array\r\n                range.shift();\r\n            }\r\n            // define the new average value and add to the middle of the range array\r\n            let newMidPoint = (range[0] + range[1]) / 2;\r\n            range.splice(1, 0, newMidPoint);\r\n    }\r\n    return bits;\r\n}\r\n\r\n//since long = odd bits and lat = even bits, we need to ensure correct length for odd values of totalBitLength\r\nfunction getBitLengthForLatOrLong(totalLength, range) {\r\n    //if dealing with latitude string\r\n    if (range[0] === -90) {\r\n        return  Math.floor(totalLength / 2);\r\n    //if dealing with longitude string\r\n    } else if (range[0] === -180) {\r\n        return Math.round(totalLength / 2);\r\n    }\r\n}\r\n\r\nfunction mergeArrays(array1, array2) {\r\n    let j = Math.min(array1.length, array2.length);\r\n    let result = [];\r\n    for (let i = 0; i < j; i++) {\r\n        result.push(array1[i], array2[i]);\r\n    }\r\n    //check if the first array is longer and add the last value if so\r\n    if ((array1.length + array2.length)%2 !== 0) {\r\n        result.push(array1[array1.length - 1]);\r\n    }\r\n    return result;\r\n}\r\n\r\nfunction getGeohashString(binaryArray) {\r\n    let bits = [];\r\n    let decimals = [];\r\n    let binaryString = binaryArray.join('');\r\n\r\n    //split the string into 5 bit blocks (each block represents a decimal number)\r\n    for (let i = 0; i < binaryString.length; i += 5) {\r\n        let bit = binaryString.substring(i, i+5);\r\n        bits.push(bit)\r\n    };\r\n    \r\n    //convert 5 bit binary number into a base 10 number\r\n    for (let j = 0; j < bits.length; j++) {\r\n        let decimal = parseInt(bits[j], 2)\r\n        decimals.push(decimal);\r\n    }\r\n\r\n    let string = convertDecimalToString(decimals);\r\n    return string;\r\n}\r\n\r\nfunction convertDecimalToString(decimalArray) {\r\n    const base32 = '0123456789bcdefghjkmnpqrstuvwxyz';\r\n    let string = '';\r\n    for (var i = 0; i < decimalArray.length; i++) {\r\n        string += base32.charAt(decimalArray[i]);\r\n    }\r\n    return string;\r\n}\r\n\r\nexport { getStringForGivenLatLong };","import React from 'react';\r\nimport { Map } from './Map.js';\r\nimport { getUserLocation, getLocationAccuracy } from '../Algorithms/userLocation.js';\r\nimport { getStringForGivenLatLong } from '../Algorithms/locationAlgorithm.js';\r\n\r\nclass UserLocation extends React.Component {\r\n    constructor(props) {\r\n      super(props);\r\n      this.state = {\r\n        stringLength: 6,\r\n        string: null,\r\n        userLocation: null,\r\n        latAccuracy: 0,\r\n        longAccuracy: 0,\r\n        requestSubmitted: false\r\n      };\r\n    }\r\n    async componentDidMount() {\r\n      let coords = await getUserLocation();\r\n      this.setState({userLocation: coords});\r\n    }\r\n    setCharacterLength = (event) => {\r\n      this.setState({stringLength: event.target.value});\r\n    }\r\n    getString = () => {\r\n      if (this.state.UserLocation === null) {\r\n        alert(\"User location not found - please wait a few seconds and try again (if the problem persists, check that your location can be shared\");\r\n      } else {\r\n        this.setState({\r\n          string: getStringForGivenLatLong(this.state.userLocation, this.state.stringLength),\r\n          latAccuracy: getLocationAccuracy(this.state.stringLength, \"lat\"),\r\n          longAccuracy: getLocationAccuracy(this.state.stringLength, \"long\"),\r\n          requestSubmitted: true\r\n        });\r\n      }\r\n    }\r\n    renderMap() {\r\n      if (this.state.userLocation === null) {\r\n        return (\r\n          <div id=\"loadingState\">\r\n            <p className=\"loadingText\">Finding location...</p>\r\n          </div>\r\n        )\r\n      } else {\r\n          return (\r\n            <Map \r\n              latitude={this.state.userLocation.latitude}\r\n              longitude={this.state.userLocation.longitude}\r\n              minLatitude={this.state.userLocation.latitude - this.state.latAccuracy}\r\n              maxLatitude={this.state.userLocation.latitude + this.state.latAccuracy}\r\n              minLongitude={this.state.userLocation.longitude - this.state.longAccuracy}\r\n              maxLongitude={this.state.userLocation.longitude + this.state.longAccuracy}\r\n              label={this.state.string}\r\n              showResults={this.state.requestSubmitted}\r\n            />\r\n          )\r\n      }\r\n    }\r\n    render() {\r\n      return (\r\n        <React.Fragment>\r\n          <h2>Get your location</h2>\r\n          <p>Select the accuracy (i.e. string length) and click \"submit\" to Geohash your current location</p>\r\n          <div id=\"stringLength\">\r\n            <label className=\"stringLength\">\r\n              <input\r\n                type=\"range\"\r\n                className=\"slider\"\r\n                min=\"2\" max=\"12\" step=\"1\"\r\n                defaultValue=\"6\"\r\n                onInput={this.setCharacterLength}\r\n              />\r\n              String length: {this.state.stringLength} characters\r\n            </label>\r\n          </div>\r\n          <div id=\"buttonWrapper\">\r\n            <input\r\n              type=\"button\"\r\n              value=\"Submit\"\r\n              onClick={this.getString}\r\n            />\r\n          </div>\r\n          {this.renderMap()}\r\n          </React.Fragment>\r\n      );\r\n    }\r\n  }\r\n\r\n  export { UserLocation }","function getURLQueryGeohash() {\r\n    const urlQuery = new URLSearchParams(window.location.search);\r\n    let geohashString = getStringFromParams(urlQuery);\r\n    return geohashString;\r\n}\r\n\r\nfunction getStringFromParams(params) {\r\n    if (params.has('string')) {\r\n        return params.get('string');\r\n    } else if (params.has('geohash')) {\r\n        return params.get('geohash');\r\n    } else {\r\n        //if no string is explicity defined, return the param in full [minus the '=' that toString() adds]\r\n        return params.toString().replace('=', '');\r\n    }\r\n}\r\n\r\n\r\nexport { getURLQueryGeohash }","import React from 'react';\r\nimport { Splash } from './Splash.js'\r\nimport { TopBar } from './TopBar.js';\r\nimport { StringInput } from './StringInput.js';\r\nimport { UserLocation } from './UserLocation.js';\r\nimport { getURLQueryGeohash } from '../Algorithms/urlQuery.js';\r\nimport { unstable_renderSubtreeIntoContainer } from 'react-dom';\r\n\r\nclass App extends React.Component {\r\n    constructor(props) {\r\n      super(props);\r\n      this.state = {\r\n        urlQuery: getURLQueryGeohash(),\r\n        function: \"\",\r\n        menuOpen: false,\r\n        appStarted: false\r\n      };\r\n    }\r\n    checkForURLQuery() {\r\n      if (this.state.urlQuery.length < 1) {\r\n        return;\r\n      } else {\r\n        this.setState({\r\n          function: \"userInput\",\r\n          appStarted: true\r\n        });\r\n      }\r\n    }\r\n    componentDidMount() {\r\n      this.checkForURLQuery();\r\n    }\r\n    changeFunction = (event) => {\r\n      this.setState({\r\n          function: event.target.value,\r\n          menuOpen: !this.state.menuOpen,\r\n          appStarted: true\r\n        });\r\n    }\r\n    switchAppFunction() {\r\n      if (this.state.function === \"userInput\") {\r\n        return <StringInput string={this.state.urlQuery}/>\r\n      } else if (this.state.function === \"userLocation\") {\r\n        return <UserLocation/>\r\n      };\r\n    }\r\n    toggleMenu = (event) => {\r\n        this.setState({\r\n            menuOpen: !this.state.menuOpen\r\n        });\r\n    }\r\n    renderMenu() {\r\n        if (this.state.menuOpen) {\r\n            return (\r\n                <div id=\"appOptions\" onChange={this.changeFunction}>\r\n                  <label>\r\n                    Enter a custom Geohash string<br />\r\n                    <input type=\"radio\" value=\"userInput\" name=\"selectFunction\"/>\r\n                  </label>\r\n                  <label>\r\n                    Find your current location<br />\r\n                    <input type=\"radio\" value=\"userLocation\" name=\"selectFunction\"/>\r\n                  </label>\r\n                </div>\r\n            )\r\n        }\r\n    }\r\n    renderSplash() {\r\n        if (!this.state.appStarted) {\r\n            return (\r\n                <Splash/>\r\n            )\r\n        }\r\n    }\r\n    render() {\r\n      return (\r\n        <div id=\"wrapper\">\r\n            <TopBar toggleMenu={this.toggleMenu}/>\r\n            {this.renderMenu()}\r\n            {this.renderSplash()}\r\n            <div id=\"userInterface\">\r\n                {this.switchAppFunction()}\r\n            </div>\r\n        </div>\r\n      );\r\n    }\r\n  }\r\n\r\n  export { App };","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { App } from './Components/App.js';\r\nimport './index.css';\r\n\r\n  \r\nReactDOM.render(\r\n  <App />,\r\n  document.getElementById('root')\r\n);\r\n  "],"sourceRoot":""}